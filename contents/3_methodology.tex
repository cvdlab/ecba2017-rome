\section{Methodology}

\subsection{Centralized state}
La realizzazione del sistema è stata effettuata utilizzando alcune tra le tecnologie ed i pattern più in auge nello sviluppo di applicazioni web-oriented. Nello specifico sono stati utilizzati i pattern Unidirectional Data Flow e Immutability attraverso l’implementazione messa a disposizione rispettivamente dalle librerie ReduxJS e ImmutableJS.


Lo sviluppo del progetto si è focalizzato sull'individuazione di una struttura gerarchica in grado di rappresentare in modo esaustivo l’insieme delle componenti che compongono la planimetria, costituendo di fatto lo stato dell’applicazione. Lo stato è stato gestito attraverso l’immutabilit\`a, un principio che prevede l’applicazione di nuove modifiche attraverso la generazione di un nuovo stato, in primis identico al precedente, ma sul quale vengono applicate le modifiche richieste. Dal punto di vista della gestione della memoria questo meccanismo richiederebbe un importante dispendio di risorse. Per evitare ciò l’implementazione ImmutableJS adotta dei meccanismi che simulano il principio di immutabilit\`a evitando la copia in profondit\`a della memoria  (deep clone) e alleggerendo così il carico in termini di utilizzo di memoria e tempo macchina.


\subsubsection{Application as Finite State Machine}
Per dominare la complessit\`a dell’applicazione l’intero sistema è stato modellato su una macchina a stati. Sfruttando il modello basato su azioni e reducer messo a disposizione dal pattern unidirectional data flow è stato individuato un grafo che rappresenta le possibili evoluzioni dello stato dell’applicazione. Il nodo corrente in cui si trova la macchina a stati è stato mappato attraverso l’introduzione di una variabile globale che rappresenta la modalit\`a in cui si trova l’applicazione, gli eventi del browser sono stati mappati con gli archi uscenti del grafo.Ad esempio un’operazione di creazione di un nuovo muro viene mappata attraverso un grafo composto da 4 nodi.\newline

\begin{figure}[!t]
\centering
\includegraphics[width=\linewidth]{contents/images/uc_draw_wall}

\caption{Bla bla bla.}
\label{fig_sim}
\end{figure}




\subsection{Collaboration}
    COLLABORAZIONE\\

\subsection{Building elements}

Il catalogo del programma è un insieme, strutturato in categorie, nel quale sono contenuti tutti gli elementi costruttivi che è possibile inserire all’interno della planimetria. L’attribuzione della categoria viene effettuata sulla base delle caratteristiche dell’elemento e determina i casi d’uso permessi all’utente.
Le categorie sono:\\
\textbf{Walls}, rientrano in questa categoria tutti i tipi di muro (perimetrali, interni, portanti). La creazione avviene specificando il punto di inizio e fine dell’elemento. La rappresentazione interna dei muri viene ricondotta a quella di un grafo in cui i nodi, che corrispondono ai punti geometrici in cui si intersecano più muri, hanno delle coordinate che li collocano nello spazio e gli archi sono l’area visibile del muro.\\
\textbf{Openings}, rientrano in questa categoria gli elementi che bucano i muri come porte, finestre e archi. La creazione viene effettuata attraverso uno snap sui muri precedentemente creati. L’utente può agire sulla posizione ed il sistema garantisce che questa venga preservato il legamente con il muro. \\
\textbf{Areas}, rientrano in questa categoria i pavimenti. La creazione viene effettuata automaticamente attraverso un’analisi della disposizione dei muri. L’algoritmo individuato viene di seguito descritto.\\
\textbf{Objects}, rientrano in questa categoria tutti gli oggetti posizionabili sulle aree. L’utente può agire sulla disposizione sia in termini di posizione che rotazione.\\

\subsection{UI components}

L'intera applicazione \`e stata pensata in maniera modulare, in modo da poterla estendere in maniera semplice. Dal punto di vista web la tecnologia applicata è stata quella dei \textbf{Web Components}. L'idea di base è quello di definire l'applicazione frontend come una collezione di componenti, che vengono renderizzati in modo diverso a seconda dei valori assegnati allo stato. In particolare, vi è una classe di componenti delegati alla rappresentazione delle propriet\`a dello stato stesso: i \textbf{viewers}. Esempi sono i visualizzatori per il 2D e per il 3D. In generale, la struttura a componenti permette di definire una qualunque visualizzazione dello stato (ad esempio in forma tabellare) semplicemente inserendo un nuovo componente. Una schematizzazione del concetto è evidenziata nella figura~\ref{fig_viewers}.\\

Come possiamo vedere nello schema, siamo in grado di identificare tre macro blocchi. Il primo è il catalogo, che come abbiamo visto (CITAZIONE AL PARAGRAFO) contiene tutti i building elements del sistema e le loro properiet\`a. Il secondo \`e il core vero e proprio e si occupa della gestione dello stato e contiene le funzionalità di disegno. Questo comunica con il catalogo prendendo le propriet\`a dei building elements. Infine abbiamo i visualizzatori veri e propri, che vengono scelti in base alla \texttt{mode} property inside the state.\\

Al momento sono stati implementati i visualizzatori 2D e 3D.\\\\
\textbf{2D Viewer}. This viewer creates a 2D view of the building model. Dato lo stato globale, è in grado di sfruttare il \textbf{Virtual DOM} per aggiornare solo le parti che vengono modificate evitando aggiornamenti globali continui\\\\
\textbf{3D Viewer}. Sfrutta la libreria di modellazione per WebGL \textbf{ThreeJS} per creare una vista 3D del building model. Per evitare di dover continuamente ricreare l'intero modello quando cambiano porzioni dello stato, \`e stato implementato un sistema di \textit{diff} e \textit{patch} dello stato (usando la libreria \texttt{immutable-js-diff}) che a sua volta si riconduce allo stato citato in~\cite{rfc6902}. In pratica è stata creata una struttura parallela che mappa gli oggetti di ThreeJS con i relativi building elements memorizzati nello stato. Ogni volta che viene lanciata un'azione redux, viene calcolata la diff tra il vecchio stato e quello nuovo e si ricreano solo gli oggetti che sono stati modificati. In particolare possiamo avere tre possibili \textit{operations}: (i) \textbf{add}, (ii) \textbf{replace} and (iii) \textbf{remove}. For every operation, viene determinato un diverso tipo di comportamento in base al particolare building element cambiato, coinvolgendo eventualmente building elements correlati

\begin{figure}[!t]
\centering
\includegraphics[width=\linewidth]{contents/images/diagramma-visualizzatori}

\caption{The architectural schema for the viewers. Here we can see that the core can instanziate several different viewers giving them the state for the representation}
\label{fig_viewers}
\end{figure}

\subsubsection{3D renderer component}
threeJS immutablediff

\subsection{Architettura serverless}
    CARICO FRONTEND\\
    CARICAMENTO REMOTO GEOMETRIA PLUGIN\\